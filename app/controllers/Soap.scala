package controllers

import play.Logger
import play.api.mvc._
import play.api.libs.iteratee._
import models._

object Soap extends Controller {

  def index(environment: String, localTarget: String) = Action(parse.xml) {
    implicit request =>

      Logger.info("Request on environment:" + environment + " localTarget:" + localTarget)

      val sender = request.remoteAddress
      val content = request.body.toString()
      val headers = request.headers.toSimpleMap
      forwardRequest(environment, localTarget, sender, content, headers)
  }


  /**
   * An url is composed of the following members :
   * protocol://host:port/path
   * This operation return the URL's path using classical Java net operation
   * @param textualURL The url from which extract and return the path
   * @return The url's path
   */
  def extractPathFromURL(textualURL : String ) : String = {
      val urlObject = new java.net.URL(textualURL)
      urlObject.getPath().substring(1)  // Extract the path without the first char of the string because it's a useless '/'
  }


  /**
   * Automatically detect new services. If the given parameters interpolates an existing service, then nothing is created otherwise a new service is created.
   * The new service takes the given parameters and theses defaults parameters :
   * <ul>
   * <li>record Xml Data set to false</li>
   * <li>record All Data set to false</li>
   * <li>timeoutms set to default (60000ms)</li>
   * </ul>
   * After this the equivalent of  {@link Soap#index} is made.
   *
   * @param group The group of soap request. It is a logical separation between environments.
   * @param environment The environment group of the soap request. It is a logical separation between services.
   * @param remoteTarget The remote target to be call. The underlying soap request is forwarded to this remote target.
   */
  def autoIndex(group: String, environment: String, remoteTarget: String) = Action(parse.xml) {
    implicit request =>

      // Extract local target from the remote target
      val localTarget = extractPathFromURL(remoteTarget)

      Logger.info("Automatic service detection request on group: " + group + " environment:" + environment + " localTarget:" + localTarget + " remoteTarget: " + remoteTarget)

      // Search the corresponding service
      val optionService = Service.findByLocalTargetAndEnvironmentName(localTarget, environment)

      var service: Service = null.asInstanceOf[Service]

      optionService match {
        case Some(realService) =>
          // If the service exists
          service = realService
        case None => {
          // If the service doesn't exits {
          val id = -1
          val description = "this service was automatically generated by soapower"
          val timeoutms = 60000
          val recordXmlData = false
          val recordData = false

          val environmentOption = Environment.findByGroupAndByName(group, environment)
          // Check that the environment exists for the given group
          environmentOption.map {
            environmentReal =>
            // The environment exists so the service creation can be performed
              service = new Service(id,
                description,
                localTarget,
                remoteTarget,
                timeoutms,
                recordXmlData,
                recordData,
                environmentReal.id)
              // Persist environment to database
              Service.insert(service)
          }.getOrElse {
            val err = "environment " + environment + " with group " + group + " unknown"
            Logger.error(err)
            BadRequest(err)
          }
        }
      }

      //
      // Now the service exists then we have to forward the request
      //
      val sender = request.remoteAddress
      val content = request.body.toString()
      val headers = request.headers.toSimpleMap
      forwardRequest(environment, localTarget, sender, content, headers)
  }


  /**
   * Replay a given request.
   */
  def replay(requestId: Long) = Action {
    val requestData = RequestData.load(requestId)

    val environmentTuple = Environment.optionsAll.find {
      case (k, v) => k == requestData.environmentId.toString
    }

    if (!environmentTuple.isDefined) {
      val err = "environment with id " + requestData.environmentId + " unknown"
      Logger.error(err)
      BadRequest(err)

    } else {
      val sender = requestData.sender
      val content = requestData.request
      val headers = requestData.requestHeaders
      val environmentName = environmentTuple.get._2
      if (requestData.serviceId > 0) {
        val service = Service.findById(requestData.serviceId).get
        forwardRequest(environmentName, service.localTarget, sender, content, headers)
      } else {
        val err = "service with id " + requestData.serviceId + " unknown"
        Logger.error(err)
        BadRequest(err)
      }
    }
  }

  private def forwardRequest(environmentName: String, localTarget: String, sender: String, content: String, headers: Map[String, String]): PlainResult = {
    val service = Service.findByLocalTargetAndEnvironmentName(localTarget, environmentName)
    service.map {
      service =>
      // forward the request to the actual destination
        val client = new Client(service, sender, content, headers)
        client.sendRequestAndWaitForResponse

        // forward the response to the client
        new Results.Status(client.response.status).stream(Enumerator(client.response.bodyBytes).andThen(Enumerator.eof[Array[Byte]]))
          .withHeaders("ProxyVia" -> "soapower")
          .withHeaders(client.response.headers.toArray: _*).as(XML)

    }.getOrElse {
      val err = "environment " + environmentName + " with localTarget " + localTarget + " unknown"
      Logger.error(err)
      BadRequest(err)
    }
  }

  def printRequest(implicit r: play.api.mvc.RequestHeader) {
    Logger.info("method:" + r)
    Logger.info("headers:" + r.headers)
    //Logger.info("SoapAction:" + r.headers("SOAPACTION"))
    Logger.info("path:" + r.path)
    Logger.info("uri:" + r.uri)
    Logger.info("host:" + r.host)
    Logger.info("rawQueryString:" + r.rawQueryString)
  }

}
